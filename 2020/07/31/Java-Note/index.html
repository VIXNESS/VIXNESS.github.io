<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png?v=7.3.0">
  <link rel="manifest" href="/images/favicons/site.webmanifest">
  <meta name="msapplication-config" content="/images/favicons/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":true,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="Java NoteI 虚拟机内存布局1. JVM运行时 内存布局   区域 作用 线程内存共享 异常 异常原因     方法区 存放类型信息, 常量, 静态变量, JIT代码缓存. 线程共享 OOM JVM规范规定, 无法满足内存分配时可抛出.   虚拟机栈 存储局部变量, 操作数栈,  动态链接, 接口等. 线程私有 OOM, SO SO: 栈深度超出JVM允许范围;OOM: 栈扩展失败导致的内">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Note">
<meta property="og:url" content="http://meolin.net/2020/07/31/Java-Note/index.html">
<meta property="og:site_name" content="喵灵">
<meta property="og:description" content="Java NoteI 虚拟机内存布局1. JVM运行时 内存布局   区域 作用 线程内存共享 异常 异常原因     方法区 存放类型信息, 常量, 静态变量, JIT代码缓存. 线程共享 OOM JVM规范规定, 无法满足内存分配时可抛出.   虚拟机栈 存储局部变量, 操作数栈,  动态链接, 接口等. 线程私有 OOM, SO SO: 栈深度超出JVM允许范围;OOM: 栈扩展失败导致的内">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://meolin.net/images/Java_Note/0.png">
<meta property="og:image" content="http://meolin.net/images/Java_Note/1.png">
<meta property="og:updated_time" content="2020-07-31T04:02:10.244Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Note">
<meta name="twitter:description" content="Java NoteI 虚拟机内存布局1. JVM运行时 内存布局   区域 作用 线程内存共享 异常 异常原因     方法区 存放类型信息, 常量, 静态变量, JIT代码缓存. 线程共享 OOM JVM规范规定, 无法满足内存分配时可抛出.   虚拟机栈 存储局部变量, 操作数栈,  动态链接, 接口等. 线程私有 OOM, SO SO: 栈深度超出JVM允许范围;OOM: 栈扩展失败导致的内">
<meta name="twitter:image" content="http://meolin.net/images/Java_Note/0.png">
  <link rel="canonical" href="http://meolin.net/2020/07/31/Java-Note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java Note | 喵灵</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">喵灵</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">meolin</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    

  <a href="https://github.com/vixness" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://meolin.net/2020/07/31/Java-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Tao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="喵灵">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Java Note

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-07-31 11:54:00 / 修改时间：12:02:10" itemprop="dateCreated datePublished" datetime="2020-07-31T11:54:00+08:00">2020-07-31</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-Note"><a href="#Java-Note" class="headerlink" title="Java Note"></a>Java Note</h1><h2 id="I-虚拟机内存布局"><a href="#I-虚拟机内存布局" class="headerlink" title="I 虚拟机内存布局"></a>I 虚拟机内存布局</h2><h3 id="1-JVM运行时-内存布局"><a href="#1-JVM运行时-内存布局" class="headerlink" title="1. JVM运行时 内存布局"></a>1. JVM运行时 内存布局</h3><table>
<thead>
<tr>
<th>区域</th>
<th>作用</th>
<th>线程内存共享</th>
<th>异常</th>
<th>异常原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法区</td>
<td>存放类型信息, 常量, 静态变量, JIT代码缓存.</td>
<td>线程共享</td>
<td>OOM</td>
<td>JVM规范规定, 无法满足内存分配时可抛出.</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>存储局部变量, 操作数栈,  动态链接, 接口等.</td>
<td>线程私有</td>
<td>OOM, SO</td>
<td>SO: 栈深度超出JVM允许范围;<br>OOM: 栈扩展失败导致的内存分配不足.</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>与虚拟机栈功能相同, 但是对象是本地方法(Native Method).</td>
<td>线程私有</td>
<td>OOM, SO</td>
<td>同上.</td>
</tr>
<tr>
<td>堆</td>
<td>绝大部分对象在此存储(除了栈上分配和标量替换的对象).</td>
<td>共享/私有(TLAB)</td>
<td>OOM</td>
<td>堆中无法完成实例分配时抛出.</td>
</tr>
<tr>
<td>PC计数器</td>
<td>下一条指令的地址</td>
<td>线程私有</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table><a id="more"></a>
<blockquote>
<p>OOM: OutOfMemoryError</p>
<p>SO: StackOverFlowError</p>
<p>TLAB: 线程私有分配缓冲区 Thread Local Allocation Buffer</p>
</blockquote>
<h3 id="2-对象内存布局"><a href="#2-对象内存布局" class="headerlink" title="2. 对象内存布局"></a>2. 对象内存布局</h3><p>堆中对象的布局: 对象头 + 数据 + 对其填充.</p>
<p>对象头: 锁信息, GC信息, 偏向信息.</p>
<h3 id="3-对象访问"><a href="#3-对象访问" class="headerlink" title="3. 对象访问"></a>3. 对象访问</h3><h4 id="3-1-句柄访问"><a href="#3-1-句柄访问" class="headerlink" title="3.1 句柄访问"></a>3.1 句柄访问</h4><p><img src="/images/Java_Note/0.png" alt="句柄"> </p>
<h4 id="3-2-指针访问"><a href="#3-2-指针访问" class="headerlink" title="3.2 指针访问"></a>3.2 指针访问</h4><p><img src="/images/Java_Note/1.png" alt="指针"> </p>
<h2 id="II-垃圾回收策略"><a href="#II-垃圾回收策略" class="headerlink" title="II 垃圾回收策略"></a>II 垃圾回收策略</h2><h3 id="1-回收理论"><a href="#1-回收理论" class="headerlink" title="1. 回收理论"></a>1. 回收理论</h3><h4 id="对象存活判定"><a href="#对象存活判定" class="headerlink" title="对象存活判定"></a>对象存活判定</h4><p>应回收对象的判断: 可达性分析.</p>
<blockquote>
<p>可达性分析:</p>
<p>以一些可作为GC Root的对象为根的一棵由引用关系建立起来的树, 当树根死去, 整个棵树上的对象都将不可达.</p>
<p>什么对象可作为GC Root:</p>
<ul>
<li>虚拟栈中引用的对象</li>
<li>方法区中静态变量所引用的变量</li>
<li>常量引用的对象</li>
<li>JVM内部引用(例如一些Class对象, 异常对象, 类加载器)</li>
<li>synchronized持有的对象</li>
</ul>
</blockquote>
<h4 id="分代假说"><a href="#分代假说" class="headerlink" title="分代假说"></a>分代假说</h4><ul>
<li>大多数对象都是朝生夕灭的.</li>
<li>几次GC之后仍然存活的对象是不朽的.</li>
<li>跨代引用(新生代, 老年代之间的引用) 是极少的.</li>
</ul>
<p>所以将需要GC的区域分为Eden区和Survivors区.</p>
<p>新建立的对象放在Eden区.</p>
<p>经过几代GC仍然存活的对象放入Survivors区.</p>
<h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><ol>
<li>标记 - 清除:  (产生大量碎片)<ol>
<li>先标记需要回收的对象.</li>
<li>清除对象.</li>
</ol>
</li>
<li>标记 - 复制: (将区域划分为两个区域, 回收时从一个区域把存活对象复制到另一个区域, 并且紧密排列)<ol>
<li>先标记要回收的对象.</li>
<li>复制存活到对象到另一个半区.</li>
</ol>
</li>
<li>标记 - 整理: (移动每次都存活的老年代代价是非常高的, 而且需要暂停用户线程)<ol>
<li>先标记要回收的对象.</li>
<li>将存活的对象进行整理, 使其紧密排列.</li>
</ol>
</li>
</ol>
<h3 id="2-回收时机"><a href="#2-回收时机" class="headerlink" title="2. 回收时机"></a>2. 回收时机</h3><p>强引用: 一般的声明的对象, 只要关系存在, 不会被回收.</p>
<p>软引用: 非必须对象,  SoftReference,  在内存溢出之前优先回收.</p>
<p>弱引用: 非必须对象, WeakReference, 一旦触发GC就立刻回收.</p>
<p>虚引用: 不影响对象的声明走起, PhantomReference, 无法取得实例数据, 只能用于接受GC回收的通知.</p>
<p>Minor GC触发:  实例分配失败, Eden区满了.</p>
<p>Full GC触发:  <code>System.gc()</code> , heap dump,  Survivor区的大小无法满足Minor GC后的对象.</p>
<blockquote>
<p>Minor GC: 只回收新生代</p>
</blockquote>
<h3 id="3-回收器例举"><a href="#3-回收器例举" class="headerlink" title="3. 回收器例举"></a>3. 回收器例举</h3><h4 id="3-1-Serial-ParNew"><a href="#3-1-Serial-ParNew" class="headerlink" title="3.1 Serial / ParNew"></a>3.1 Serial / ParNew</h4><p>新生代: 标记 - 复制</p>
<p>老年代: 标记 - 清理</p>
<h4 id="3-2-CMS-注重响应时间-停顿时间短"><a href="#3-2-CMS-注重响应时间-停顿时间短" class="headerlink" title="3.2 CMS(注重响应时间, 停顿时间短)"></a>3.2 CMS(注重响应时间, 停顿时间短)</h4><p>使用标记 - 清除算法. </p>
<ol>
<li>初始标记: 标记GC Root直接关联的对象. (需要Stop The World)</li>
<li>并发标记: 从GC Root开始遍历对象图. </li>
<li>重新标记: 修正并发标记时对象的变动. (需要Stop The World)</li>
<li>并发清除. <strong>(Major GC)</strong></li>
</ol>
<blockquote>
<ul>
<li>CMS无法处理<strong>浮动垃圾</strong>,  因而引发一次Full GC. (浮动垃圾是指CMS在并发清理的时候, 伴随着产生的新垃圾对象.)</li>
<li>CMS收集完成后, 内存空间有碎片存在.</li>
</ul>
</blockquote>
<h4 id="3-3-G1-Mixed-GC"><a href="#3-3-G1-Mixed-GC" class="headerlink" title="3.3 G1 (Mixed GC)"></a>3.3 G1 (Mixed GC)</h4><blockquote>
<p> G1将空间分为大小不一的Region, 每个Region可作为Eden, Survivor空间.</p>
</blockquote>
<p>GC步骤:</p>
<ol>
<li>初始标记: 同CMS(需要Stop The World)</li>
<li>并发标记: 同CMS</li>
<li>最终标记: 修正并发标记时对象的变动. (需要Stop The World)</li>
<li>筛选回收: 根据Region的统计数据对Region进行回收</li>
</ol>
<h4 id="3-4-ZGC"><a href="#3-4-ZGC" class="headerlink" title="3.4 ZGC"></a>3.4 ZGC</h4><blockquote>
<p>与G1一样, 也是使用大小不同的Region拆分回收区域.</p>
<p>并且使用染色指针技术.(具体原理略)</p>
</blockquote>
<p>GC步骤:</p>
<ol>
<li>并发标记: 同CMS</li>
<li>并发预备重分配: 根据查询条件统计出需要回收的Region.</li>
<li>并发重分配: 把集中存活的对象复制到新Region上.</li>
<li>并发重映射: 修正堆中指向旧对象的引用.</li>
</ol>
<h2 id="III-类加载机制"><a href="#III-类加载机制" class="headerlink" title="III 类加载机制"></a>III 类加载机制</h2><h3 id="1-类加载步骤"><a href="#1-类加载步骤" class="headerlink" title="1. 类加载步骤"></a>1. 类加载步骤</h3><ol>
<li><p>加载: 从不同的源头读取二进制字节流, 并且创建Class对象.</p>
</li>
<li><p>验证: 验证文件.</p>
</li>
<li><p>准备: 为静态变量设定初始值(不是赋语句中定义的值, 而是各类型的默认值, 例如int的默认值是0). 初始在方法区.</p>
</li>
<li><p>解析: 将常量池中的符号引用替换为直接引用. (包括类、接口的解析, 字段的解析, 方法的解析, 接口方法的解析)</p>
</li>
<li><p>初始化: 初始化变量, 赋值实际的值给变量. 执行类构造器\&lt;clinit>().</p>
</li>
</ol>
<h3 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3><blockquote>
<p>不同类加载器加载的同一个类在JVM中不视为同一个类.</p>
</blockquote>
<h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p><strong>双亲委派模型</strong> (递归加载)</p>
<ol>
<li>遇到要加载的类优先交由父类加载.</li>
<li>父类无法加载的类再由子类加载.</li>
</ol>
<p><strong>非双亲委派模型</strong></p>
<ol>
<li>线程上下文加载器: 可由父类请求子类类加载器加载.</li>
<li>模块化系统:  若可以找到对应的模块类加载器, 优先派发给其加载. 否则交由父类加载.</li>
</ol>
<h3 id="3-反射系统"><a href="#3-反射系统" class="headerlink" title="3. 反射系统"></a>3. 反射系统</h3><p>反射系统主要是基于Class对象的操作.</p>
<p>当类加载器从不同渠道加载完Java类后, 都会形成这个类加载器下一一对应的Class对象(当然, 不同的类加载器加载的同一个类不是同一个Class对象).</p>
<h2 id="IV-多线程并发"><a href="#IV-多线程并发" class="headerlink" title="IV 多线程并发"></a>IV 多线程并发</h2><h3 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1. 内存模型"></a>1. 内存模型</h3><p>JVM主要解决各个线程的工作内存与主存之间的数据一致性问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">Thread-0-工作内存 --&gt; 一致性协议;</span><br><span class="line">Thread-1-工作内存 --&gt; 一致性协议;</span><br><span class="line">Thread-2-工作内存 --&gt; 一致性协议;</span><br><span class="line">一致性协议 --&gt; 主存;</span><br></pre></td></tr></table></figure>
<h4 id="一致性协议具体内容"><a href="#一致性协议具体内容" class="headerlink" title="一致性协议具体内容"></a>一致性协议具体内容</h4><ul>
<li>read - load: 两条指令必须按<strong><em>顺序</em></strong>使用, 且必须<strong><em>成对</em></strong>出现, read作用于<strong>主存</strong>, load作用于<strong>工作内存</strong>. 目的是为了把<strong>主存</strong>中的变量读入线程<strong>工作内存</strong>变为私有副本.</li>
<li>store - write: 两条指令必须按<strong><em>顺序</em></strong>使用, 且必须<strong><em>成对</em></strong>出现, store作用于<strong>工作内存</strong>, write作用于<strong>主存</strong>. 目的是把<strong>工作内存</strong>中的放入<strong>主存</strong>.</li>
<li>use/assign:  作用于<strong>工作内存</strong>, 将<strong>工作内存</strong>中的数据传输给执行引擎/将执行引擎得到的结果赋值给<strong>工作内存</strong>.</li>
<li>lock/unlock: 作用于<strong>主存</strong>, 将一个变量锁定🔒/解锁🔓为线程独占的状态. <ul>
<li>lock会导致<strong>工作内存</strong>清空, 且需要进行load(主存给出)或者assign(计算引擎给出)对变量进行赋值.</li>
<li>一个变量只能同时被一个线程lock, 但是一个变量可以被同一个线程lock多次, 不过必须有相同数量的unlock.</li>
<li>unlock之前必须有store - write 且之前必须被lock锁定.</li>
</ul>
</li>
</ul>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><p>提供了有序性: 禁止内存重排序优化*. </p>
<p>提供了可见性: 原理是直接将处理机中的Cache无效化, 使得所有线程不得不从主存里读取数据.</p>
<p><strong>不保证原子性.</strong></p>
<h3 id="2-线程实现"><a href="#2-线程实现" class="headerlink" title="2. 线程实现"></a>2. 线程实现</h3><p>Thread对象中的run()是Thread对象将执行代码逻辑的部分, 若直接调用则与普通的一个实现了run()方法的类无差别.</p>
<p>Thread对象中的start()方法作用是处理一套进程准备工作(包括调用本地系统调用创建线程). 线程创建完毕后, 将run()中写好的代码注入到该线程中执行该线程.</p>
<h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><p>定义: 多个线程同时访问一个对象时, 若不考虑线程调度, 交替, 同步手段和任何协调操作, 单次调用该对象可以获得正确结果, 称之为线程安全.</p>
<blockquote>
<p><strong>线程安全的类就不需要添加同步手段了么?</strong></p>
<p>非也.</p>
<p>大多线程安全的容器都是在方法处加入synchronized关键字, 而非在变量处.</p>
<p>这就导致两个线程同时使用两个不同的方法对统一对象进行修改, 仍然会出现线程不安全.</p>
</blockquote>
<h4 id="实现线程安全编程"><a href="#实现线程安全编程" class="headerlink" title="实现线程安全编程"></a>实现线程安全编程</h4><blockquote>
<p>线程安全的目的是线程之间必须要同步.</p>
</blockquote>
<p><strong>1.  无同步</strong></p>
<ul>
<li>使用<strong>纯代码(可重入代码)</strong> , 纯代码具有一些特性, 例如:    <ul>
<li>一些不依赖全局变量,共享变量, 不实用公共资源, 所以状态量均由参数传入.</li>
<li>结果是可预测的, 相同的输入, 结果也是相同的.</li>
</ul>
</li>
<li>使用线程本地存储TLS —— Thread Local Storage.</li>
</ul>
<p><strong>2. 非阻塞的同步</strong></p>
<blockquote>
<p> 利用 Test-and-Set, CAS等硬件指令, 实现的轻量级锁,乐观锁. </p>
</blockquote>
<p>其思想是: </p>
<ul>
<li>直接在CPU时间里测试目标是否被征用, 若没有被征用直接执行.</li>
<li>若被征用, 则直接在CPU时间内等待, 不去阻塞线程.避免了阻塞/唤醒的线程切换开销.</li>
</ul>
<p>Java中带有concrrent的类常常使用此类方法进行同步.</p>
<p><strong>3. 阻塞的同步</strong></p>
<blockquote>
<p>使用synchronized和ReentrantLock等实现的重量级锁, 悲观锁.</p>
</blockquote>
<p>在内核态, 用户态之间切换, 以阻塞/唤醒线程.</p>
<h3 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h3><h4 id="4-1-可重入锁-java-util-concurrent-locks-ReentrantLock-vs-synchronized-关键字"><a href="#4-1-可重入锁-java-util-concurrent-locks-ReentrantLock-vs-synchronized-关键字" class="headerlink" title="4.1 可重入锁  java.util.concurrent.locks.ReentrantLock vs. synchronized 关键字"></a>4.1 可重入锁  java.util.concurrent.locks.ReentrantLock vs. synchronized 关键字</h4><blockquote>
<p>可重入: 是指被中断的函数在调度回来之后可以继续执行.</p>
<p>不可重入: 是指被中断后返回后的操作已经和不中断的情况不等效了. 例如对公共变量进行操作, 突然被中断.</p>
</blockquote>
<p>可重入锁: 同一个线程对一段代码加锁之后, 中断后可再次获得该锁.</p>
<p>ReentrantLock 与 synchronized的区别在于:</p>
<ul>
<li>公平锁方面: ReentrantLock可选择为公平锁模式, 而synchronized只能为非公平锁.</li>
<li>代码方面: ReentrantLock加锁解锁不受代码块限制, 可以在一个方法中加锁, 另一个方法中解锁; synchronized只能限制在一个代码块中.</li>
<li>等待中断方面: ReentrantLock可在线程长期不释放资源的时候, 等待资源的线程放弃等待.</li>
<li>唤醒条件方面: ReentrantLock可以绑定多个条件.</li>
</ul>
<p><strong>synchronized 实现原理:</strong></p>
<p>在synchronized包裹的代码块的前后插入管程指令.</p>
<p><strong>ReentrantLock 实现原理: </strong></p>
<blockquote>
<p>数据结构: CLH队列 —— 一个基于双向链表的FIFO队列, 它和普通的队列的区别在于加入了对队列中元素的标记, 用于标记排队线程的状态.</p>
<p>PROPAGATE 节点: 唤醒它, 它还会传播式唤醒它后面的节点, 用于实现共享锁.</p>
<p>SIGNAL 节点: 等待前方的节点唤醒自己.</p>
<p>CONDITION 节点: 表示排序线程在<strong>条件队列</strong>中.</p>
<p>CANCELLED 节点: 该线程被取消.</p>
<p>0: 新进线程的节点.</p>
</blockquote>
<ul>
<li>ReentrantLock 使用 AbstractQueuedSynchronizer 来存储两个队列: 条件队列和等待队列.</li>
<li>条件队列和等待队列中存放的都是排队的线程.</li>
</ul>
<blockquote>
<p>条件队列与等待队列的作用相似, 都是存放排队的线程. </p>
<p>只是一些条件唤醒的线程尚未满足条件, 需要在条件队列中等待, 当满足条件后, 将其加入等待队列, 进行等待.</p>
<p>进入等待队列的线程, 就开始等待获取锁.</p>
</blockquote>
<p><strong>共享锁的实现</strong></p>
<p>节点带PROPAGATE标志插入等待队列, 当该节点被唤醒, 会传播唤醒后续节点.</p>
<p><strong>可重入的实现</strong></p>
<p>检查该持有锁的线程是不是当前线程, 若是则返回该锁.</p>
<p><strong>公平/非公平的实现</strong></p>
<p>公平: 先进入AQS排队.</p>
<p>非公平锁: 基于CAS检测当前是否有线程持有锁, 若没有, 进而直接插队.</p>
<h4 id="4-2-读写锁-Java-util-concurrent-locks-ReentrantReadWriteLock"><a href="#4-2-读写锁-Java-util-concurrent-locks-ReentrantReadWriteLock" class="headerlink" title="4.2 读写锁 Java.util.concurrent.locks.ReentrantReadWriteLock"></a>4.2 读写锁 Java.util.concurrent.locks.ReentrantReadWriteLock</h4><ul>
<li>多个读操作不会阻塞.</li>
<li>一个写操作阻塞所有读操作和所有写操作.</li>
</ul>
<h4 id="4-3-轻量锁"><a href="#4-3-轻量锁" class="headerlink" title="4.3 轻量锁"></a>4.3 轻量锁</h4><ul>
<li>若检测到无锁定, JVM给要加锁的对象创建一个Lock Record 存储对象头(Mark Word)的拷贝.</li>
<li>JVM使用CAS操作更新对象头至Lock Record说明该线程持有了这个锁.</li>
<li>若失败, 说明当前有线程占用该对象.</li>
<li>解锁仍使用CAS操作.</li>
</ul>
<blockquote>
<p>轻量级锁只适合至多2个线程的竞争, 多于2个将膨胀为重量级锁.</p>
</blockquote>
<h4 id="4-4-偏向锁"><a href="#4-4-偏向锁" class="headerlink" title="4.4 偏向锁"></a>4.4 偏向锁</h4><ul>
<li>该锁将偏向于第一个获得他的线程, 若锁一直没有其他线程获取, 则持有偏向锁的线程永不同步, 直接消除同步.</li>
<li>适用于只有一个线程访问同步块.</li>
</ul>
<h4 id="4-5-自旋锁"><a href="#4-5-自旋锁" class="headerlink" title="4.5 自旋锁"></a>4.5 自旋锁</h4><p>自旋锁: 在对象被锁定的时候, 让下一个请求者稍等一下 —— 即执行一下忙循环不放弃CPU.</p>
<p>自适应自旋锁:  利用算法判定是否使用自旋锁, 或者取消自旋锁.</p>
<blockquote>
<p>算法思想:</p>
<p>如果该线程刚刚成功获取到了自旋锁, 那么我们相信他这次也能获得自旋锁.</p>
<p>若该线程很少成功获得自旋锁, 那么我们就取消自旋锁.</p>
</blockquote>
<h4 id="4-6-锁消除"><a href="#4-6-锁消除" class="headerlink" title="4.6 锁消除"></a>4.6 锁消除</h4><p>编译器运行时通过<strong>逃逸分析</strong>, 判定数据不会产生<strong>线程逃逸</strong>后进行锁消除.</p>
<h4 id="4-7-锁粗化"><a href="#4-7-锁粗化" class="headerlink" title="4.7 锁粗化"></a>4.7 锁粗化</h4><p>将连续的多个对同一个对象的加锁解锁操作粗化为对一个代码块的一次性加锁解锁.</p>
<h4 id="4-8-公平锁-非公平锁"><a href="#4-8-公平锁-非公平锁" class="headerlink" title="4.8 公平锁/非公平锁"></a>4.8 公平锁/非公平锁</h4><blockquote>
<p>定义: </p>
<ul>
<li><p>公平锁 —— 按照请求锁的排队顺序分发锁.</p>
</li>
<li><p>非公平锁 —— 随机选取正在等待锁的线程, 给予其锁.</p>
</li>
</ul>
</blockquote>
<p>synchronized 关键字是非公平锁.</p>
<p>ReentrantLock 默认非公平锁, 但是可以设置为公平锁.</p>
<h4 id="4-9-双锁检测-DCL-Double-Check-Lock"><a href="#4-9-双锁检测-DCL-Double-Check-Lock" class="headerlink" title="4.9 双锁检测 DCL(Double Check Lock)"></a>4.9 双锁检测 DCL(Double Check Lock)</h4><p>原理:</p>
<ol>
<li>先检测标志, 相关判定条件(例如持有临界资源的时候放置的标志)</li>
<li>检测成功, 则进入临界区, 否则不进入.</li>
</ol>
<p>优点:</p>
<ul>
<li>可以在条件不成熟的时候不持有临界资源, 减少消耗.</li>
</ul>
<p>缺点:</p>
<ul>
<li>未使用<code>volatile</code> 的标志, 会导致从指令重排序, 导致线程不安全. 解决方法就是对需要检测的标识进行<code>volatile</code>标记.</li>
</ul>
<h4 id="4-10-Atomic类的实现原理"><a href="#4-10-Atomic类的实现原理" class="headerlink" title="4.10 Atomic类的实现原理"></a>4.10 Atomic类的实现原理</h4><p><strong>CAS: check and swap</strong></p>
<p>原理: 一条CPU指令, 具有原子性.</p>
<p>给出一个期望值, 再给出一个要替换值.</p>
<p>若测试目标符合期望值, 则将目标的值换成要替换的值.</p>
<p><strong>volatile &amp; CAS</strong></p>
<ul>
<li><p>volatile保证可见性和有序性.</p>
</li>
<li><p>CAS保证原子性.</p>
</li>
</ul>
<p>CAS的缺点:</p>
<ol>
<li>ABA问题 —— 添加版本号字段, 判定时还要判断是否版本一致.</li>
<li>CPU循环开销.</li>
<li>只能操作一个变量.</li>
</ol>
<h3 id="5-有序性-可见性-原子性"><a href="#5-有序性-可见性-原子性" class="headerlink" title="5. 有序性, 可见性, 原子性"></a>5. 有序性, 可见性, 原子性</h3><blockquote>
<p>因为没有原子性而引发并发错误的操作包括但不限于:</p>
<ul>
<li>check-then-act</li>
<li>read-modify-write</li>
</ul>
</blockquote>
<blockquote>
<p>重排序是指CPU会将无关的两个变量调序, 以达到更高的性能. 但是这往往会导致非期望的顺序.</p>
<p>禁止重排序则是将<strong>内存屏障</strong>插入代码中, 将重排序禁用.</p>
</blockquote>
<h4 id="5-1-volatitle"><a href="#5-1-volatitle" class="headerlink" title="5.1 volatitle"></a>5.1 volatitle</h4><p>volatile具有有序性: 内存屏障; 也具有可见性: 使得Cache失效.</p>
<p>volatile 变量的读操作的确很接近于读取普通变量的速度, 但是写操作需要插入大量的内存屏障, 会产生开销.</p>
<p>但大多数场景性能优于synchronized.</p>
<h4 id="5-2-synchronized"><a href="#5-2-synchronized" class="headerlink" title="5.2 synchronized"></a>5.2 synchronized</h4><p>synchronized具有: 有序性, 可见性, 原子性.</p>
<h4 id="5-3-final"><a href="#5-3-final" class="headerlink" title="5.3 final"></a>5.3 final</h4><p>不可变对象线程安全.</p>
<h3 id="6-long-amp-double"><a href="#6-long-amp-double" class="headerlink" title="6. long&amp;double"></a>6. long&amp;double</h3><p>long &amp; double 在 32-bit JVM 下是非原子性协议的, 因为JVM允许2Byte的数据类型分两次读写.</p>
<p>但是64-bit JVM不会出现这种非原子协议的情况.</p>
<h3 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6. 线程池"></a>6. 线程池</h3><p><strong>线程池的作用:</strong> </p>
<ol>
<li>减少频繁申请/销毁线程的资源.</li>
<li>减少无限制申请带来的消耗资源的风险.</li>
</ol>
<p><strong>ThreadPoolExecutor的思想:</strong></p>
<ul>
<li><p>首先将任务和线程分离,  任务放在阻塞队列或者立即执行, 线程放在线程池.</p>
</li>
<li><p>线程池和任务队列用一个线程分配器衔接.</p>
</li>
<li><p>线程分配器拿到任务后从线程池中获取线程, 然后再从阻塞队列中拿(也可以选取需要直接执行的任务) 进行执行.</p>
</li>
<li><p>线程池部分则负责线程的创建和回收, 与任务解耦.</p>
</li>
</ul>
<p><strong>任务调度思想</strong></p>
<p>线程小于核心数, 线程池正在运行, 即可执行.</p>
<p>否则加入阻塞队列, 若队列满了, 就拒绝任务.</p>
<p>线程池要是未运行, 也拒绝任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;V&gt;;<span class="comment">// 带返回的, 抛异常的Runnable</span></span><br><span class="line">Future&lt;V&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="notify-notifyAll-wait"><a href="#notify-notifyAll-wait" class="headerlink" title="notify()/notifyAll() + wait()"></a>notify()/notifyAll() + wait()</h4><p>缺点: </p>
<ul>
<li>过早唤醒: 唤醒条件未成立的情况下, 被提前唤醒.</li>
<li>信号丢失: .wait()被暂停(先notify(), 之后才wait()), 导致没有收到notify进而导致无限等待.</li>
<li>欺骗性唤醒: 没有其他线程执行而导致唤醒(小概率).</li>
<li>notifyAll()可导致多个线程的上下文切换, 开销增大.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">AtomicBoolean flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">while</span>(flag.get())&#123; <span class="comment">//保护条件</span></span><br><span class="line">                object.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" is awake."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Prepare for notifying"</span>);</span><br><span class="line">        flag.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">        object.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread th1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        th1.join();<span class="comment">//后续线程</span></span><br><span class="line">        System.out.println(<span class="string">"awake"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">th1.start();</span><br></pre></td></tr></table></figure>
<h4 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h4><blockquote>
<p>可以解决过早唤醒的问题.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//不可变对象可以避免许多问题</span></span><br><span class="line"><span class="keyword">final</span> Condition condition = lock.newCondition(); <span class="comment">//Condition由lock给出</span></span><br><span class="line">AtomicBoolean flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">Runnable runnable = ()-&gt;&#123;</span><br><span class="line">    lock.lock(); <span class="comment">//使用condition之前要上锁, 以防欺骗性唤醒, 提前唤醒, 信号丢失</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag.get()) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" is awake"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"><span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    lock.lock(); <span class="comment">//使用condition之前要上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag.set(<span class="keyword">false</span>);</span><br><span class="line">        condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(countDownLatch.getCount());</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>,<span class="number">10</span>).forEach(i -&gt; &#123;  <span class="comment">// 过多的countDown 只会让 count永远呆在0</span></span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><blockquote>
<p>原理:</p>
<ul>
<li>线程间阻塞使用ReentrantLock</li>
<li>线程间同步使用Condition</li>
</ul>
</blockquote>
<p>用法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runable lastRunnable = () -&gt; &#123;...&#125;;</span><br><span class="line"><span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(n, lastRunnable); <span class="comment">// n=调用.await()的线程个数</span></span><br><span class="line">Runable invokeAwaitRunnable = () -&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  cyclicBarrier.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(invokeAwaitRunnable).start();<span class="comment">//await()的调用数量达到n, 则cyclicBarrier自动启动lastRunnable, 无需new Thread(lastRunnable).start();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单同步:</span></span><br><span class="line"><span class="keyword">final</span> CyclicBarrier cyclicBarrierSimple = <span class="keyword">new</span> CyclicBarrier(n); </span><br><span class="line">Runnable run = ()-&gt; &#123;</span><br><span class="line">  <span class="comment">//所有线程都调用await(), 在cyclicBarrierSimple耗尽之前均阻塞, cyclicBarrierSimple一旦耗尽, 则所有调用await()的线程均唤醒.</span></span><br><span class="line">  cyclicBarrierSimple.await(); </span><br><span class="line">&#125;</span><br><span class="line">IntStream.range(<span class="number">0</span>,n).forEach(i -&gt; <span class="keyword">new</span> Thread(run).start());</span><br></pre></td></tr></table></figure>
<h2 id="V-并发容器"><a href="#V-并发容器" class="headerlink" title="V 并发容器"></a>V 并发容器</h2><h3 id="J-U-C-CopyOnWrite系列容器-vs-Collections-synchronizedCollection"><a href="#J-U-C-CopyOnWrite系列容器-vs-Collections-synchronizedCollection" class="headerlink" title="J.U.C.CopyOnWrite系列容器 vs. Collections.synchronizedCollection"></a>J.U.C.CopyOnWrite系列容器 vs. Collections.synchronizedCollection</h3><blockquote>
<ul>
<li><code>java.util.concurrent.CopyOnWriteArrayList</code> vs. <code>Collections.synchronizedList</code></li>
<li><code>java.util.concurrent.CopyOnWriteArraySet</code> vs. <code>Collections.synchronizedSet</code> </li>
</ul>
</blockquote>
<ul>
<li>CopyOnWrite 写得慢(每次都是复制), 读得快, 但读的是快照, 实时性差.</li>
<li>synchronizedCollection 说有操作均加锁, 相比于CopyOnWrite系列容器读得慢, 但写得快, 且实时性很强.</li>
</ul>
<h3 id="J-U-C-ConcurrentHashMap-vs-Hashtable-vs-Collections-synchronizedMap"><a href="#J-U-C-ConcurrentHashMap-vs-Hashtable-vs-Collections-synchronizedMap" class="headerlink" title="J.U.C.ConcurrentHashMap vs. Hashtable vs.  Collections.synchronizedMap"></a>J.U.C.ConcurrentHashMap vs. Hashtable vs.  Collections.synchronizedMap</h3><ul>
<li>ConcurrentHashMap: 将table分区, 对某些需要的区域进行加锁.</li>
<li>Hashtable: 将整个table全部加锁.</li>
<li>synchronizedMap: 对所有操作进行加锁.</li>
</ul>
<h3 id="阻塞队列-vs-并发队列-ArrayBlockingQueue-vs-ConcurrentLinkedQueue-vs-LinkedBlockingQueue"><a href="#阻塞队列-vs-并发队列-ArrayBlockingQueue-vs-ConcurrentLinkedQueue-vs-LinkedBlockingQueue" class="headerlink" title="阻塞队列 vs. 并发队列: ArrayBlockingQueue vs. ConcurrentLinkedQueue vs. LinkedBlockingQueue"></a>阻塞队列 vs. 并发队列: ArrayBlockingQueue vs. ConcurrentLinkedQueue vs. LinkedBlockingQueue</h3><blockquote>
<ul>
<li><code>java.util.concurrent.ArrayBlockingQueue</code></li>
<li><code>java.util.concurrent.ConcurrentLinkedQueue</code></li>
<li><code>java.util.concurrent.LinkedBlockingQueue</code></li>
</ul>
</blockquote>
<ul>
<li>ArrayBlockingQueue: 使用锁 + 数组.</li>
<li>ConcurrentLinkedQueue: 使用CAS + 链表.</li>
<li>LinkedBlockingQueue: 使用锁 + 链表</li>
</ul>
<blockquote>
<p> <strong>J.U.C.SynchronousQueue</strong>  —— 同步队列</p>
<p> 并不是一个实际可用于存储的队列, 它是同步队列, 用于同步生产者消费者.</p>
<p> <code>SynchronousQueue</code>本身无容量, 所有pull()进去的对象所在的线程都会阻塞, take()会恢复被阻塞的线程.</p>
<p> 类似于PV操作.</p>
</blockquote>
<h2 id="VI-程序编译"><a href="#VI-程序编译" class="headerlink" title="VI 程序编译"></a>VI 程序编译</h2><h3 id="1-前端-Java语法糖"><a href="#1-前端-Java语法糖" class="headerlink" title="1. 前端:  Java语法糖"></a>1. 前端:  Java语法糖</h3><h3 id="泛型系统"><a href="#泛型系统" class="headerlink" title="泛型系统"></a>泛型系统</h3><blockquote>
<p> Java泛型是语法糖, 生成代码时, 会类型擦除, 变成裸类型.</p>
</blockquote>
<h4 id="1-泛型理论-协变-逆变-不变"><a href="#1-泛型理论-协变-逆变-不变" class="headerlink" title="1. 泛型理论: 协变, 逆变, 不变"></a>1. 泛型理论: 协变, 逆变, 不变</h4><blockquote>
<p>定义: </p>
<ul>
<li>若 child <strong>extends</strong> parent, 且 f(child) 也是 f(parent)的派生, 称 f()为<strong>协变</strong>.</li>
<li>若 child <strong>extends</strong> parent, 而 f(parent) 是f(child) 的派生, 称f()为<strong>逆变</strong>.</li>
<li>若child <strong>extends</strong> parent, 而f(parent) 和f(child)无派生关系, 称为<strong>不变</strong>.</li>
</ul>
</blockquote>
<p>协变的核心原理是<strong>子类型可以隐式转化为父类型</strong>.</p>
<p>例如 <code>Child extends Parent</code>且<code>List&lt;Child&gt; extends List&lt;Parent&gt;</code> , 我们称<code>List&lt;&gt;</code>是协变的.</p>
<p>试想一下:</p>
<p><code>childList = [ch0, ch1, ch2, ...]</code> , 当<code>parentList = childList</code> 的时候, 其内部<code>[p0 = (parent)ch0, p1 = (parent)ch1, ...]</code> 很符合情理.</p>
<p>然而, Java泛型是基于类型擦除的泛型, 编译之后所有类型均擦除为裸类型, 所以Java的泛型系统是<strong>不变</strong>的.</p>
<p>具体的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Child&gt; <span class="comment">//  类型擦除 --&gt; List</span></span><br><span class="line">List&lt;Parent&gt; <span class="comment">// 类型擦除 --&gt; List</span></span><br></pre></td></tr></table></figure>
<p>编译后均是<code>List</code> 这个裸类型, 因为同为<code>List</code>类, 其之间不存在<code>extends</code> 或者 <code>super</code> 关系, 所以是<strong>不变</strong>.</p>
<h4 id="2-泛型符号-和-T的区别"><a href="#2-泛型符号-和-T的区别" class="headerlink" title="2. 泛型符号: ? 和 T的区别"></a>2. 泛型符号: ? 和 T的区别</h4><p>T , K, V等字母: 在<strong>定义泛型类型</strong>的时候使用, 定义后在后续的代码块中使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  <span class="function">T <span class="title">getT</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>? 通配符: 在<strong>使用泛型对象</strong>的时候使用, 限定泛型范围.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如, List&lt;T&gt; 是一个已经定义好的泛型类型, 是一个泛型容器.</span></span><br><span class="line"><span class="keyword">public</span> App&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> Animal&gt; dst, List&lt;? extends Animal&gt; src)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通配符指代:</p>
<p>若存在关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Object &lt;-- Animal</span><br><span class="line">Animal &lt;-- Wolf</span><br><span class="line">Wolf &lt;-- Dog</span><br><span class="line">Dog &lt;-- Husky</span><br><span class="line">Dog &lt;-- Alaskan</span><br><span class="line">Dog &lt;-- Samoyed</span><br></pre></td></tr></table></figure>
<p>那么</p>
<ul>
<li><p><code>? extends Dog</code> 指代的类型是: Husky, Alaskan, Samoyed以及Dog自己.</p>
</li>
<li><p><code>? super Dog</code> 指代的类型是: Object, Animal, Wolf 以及Dog自己.</p>
</li>
</ul>
<p>用途:</p>
<ul>
<li><code>? extends Dog</code> 也称生产类型. 在数据拷贝的时候, 属于生产方.</li>
<li><code>? super Dog</code> 也称消费类型. 在数据拷贝的时候, 数据消耗方.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> App&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> Dog&gt; dst, List&lt;? extends Dog&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从子类拷贝数据到父类, 可以保证类型转换到安全.</span></span><br><span class="line">    src.forEach(dst::add);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-后端-JIT-编译优化"><a href="#2-后端-JIT-编译优化" class="headerlink" title="2. 后端: JIT, 编译优化"></a>2. 后端: JIT, 编译优化</h3><p><strong>逃逸分析</strong></p>
<p>栈上分配: 无线程逃逸, 将堆中的对象放入栈中.</p>
<p>标量替换: 无方法逃逸, 将符合对象拆分成一个个基本类型.</p>
<h2 id="VII-Java-NIO"><a href="#VII-Java-NIO" class="headerlink" title="VII Java NIO"></a>VII Java NIO</h2><table>
<thead>
<tr>
<th>I/O模型</th>
<th>原理</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>BlockingI/O</td>
<td>数据等待、数据传输时均被阻塞.</td>
<td>直接阻塞进程</td>
</tr>
<tr>
<td>non-Block I/O</td>
<td>用户进程循环询问Kernel; 请求后直接得到结果:数据或者错误.</td>
<td>轮询消耗CPU资源</td>
</tr>
<tr>
<td>多路复用</td>
<td>多个I/O注册到同一个复用器上, 若无可读的数据进程阻塞;  若有可用数据则唤醒进程进行读取.<br>被select函数阻塞, 而不是被Socket I/O阻塞.</td>
<td>实现难度大</td>
</tr>
<tr>
<td>AIO</td>
<td>利用系统调用epoll, 内核准备完成后通知进程, 实现真正的异步IO.</td>
<td>实现难度大</td>
</tr>
</tbody>
</table>
<h3 id="java-nio-ByteBuffer"><a href="#java-nio-ByteBuffer" class="headerlink" title="java.nio.ByteBuffer"></a>java.nio.ByteBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flip(); <span class="comment">//保留limit到上次的位置, position归零, 用于读之前.</span></span><br><span class="line">clear(); <span class="comment">//全部归零, limit=capacity</span></span><br><span class="line">rewind();<span class="comment">//limit, position归零, 用于重写之前.</span></span><br></pre></td></tr></table></figure>
<h3 id="java-nio-channels"><a href="#java-nio-channels" class="headerlink" title="java.nio.channels.*"></a>java.nio.channels.*</h3><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="HashMap-原理"><a href="#HashMap-原理" class="headerlink" title="HashMap 原理"></a>HashMap 原理</h3><p><strong>存储原理</strong></p>
<ul>
<li>HashMap由一个数组组成, 使用拉链法进行存储.</li>
<li>当某个桶中节点大于等于8个, 链表化为红黑树.</li>
<li>当某个桶中节点小于等于6个时, 红黑树化为链表.</li>
</ul>
<blockquote>
<blockquote>
<p><strong>大于等于8个元素时, 为什么要化为红黑树?</strong></p>
<p>元素过多, 树形数据结构的搜索速度是$O(\lg n)$ 而线性结构是$O(n)$ .</p>
<p>所以应该使用BST之类的树, 例如AVL, 红黑树.</p>
</blockquote>
<blockquote>
<p><strong>为什么使用红黑树这个结构?</strong> </p>
<p>红黑树等价于4阶B树, 在失衡的时候, 其等价于B树2、3阶的节点吸收了失衡, 相比于AVL减少了旋转次数.</p>
</blockquote>
<blockquote>
<p><strong>为什么化为树的阈值是8</strong>? </p>
<ul>
<li>TreeNodes占用空间是普通Nodes的两倍, 过早的化为树, 空间代价过高;过晚的化为树, 搜索的时间代价过高.</li>
<li>理想情况下随机hashCode算法下所有桶中节点的分布频率会遵循<strong>泊松分布</strong>, 当某个节点大于8的时候, 其概率为100万分之6. <a href="https://www.javazhiyin.com/34651.html" target="_blank" rel="noopener">*注</a> </li>
</ul>
</blockquote>
<blockquote>
<p><strong>为什么化为链表的阈值是6?</strong></p>
<p>因为在8个节点左右反复插入删除, 会导致反复的链表和树的转化, 引起波动.</p>
</blockquote>
</blockquote>
<h3 id="反射的代价"><a href="#反射的代价" class="headerlink" title="反射的代价"></a>反射的代价</h3><ul>
<li>检查方法可见性</li>
<li>校验参数</li>
<li>JIT无法优化</li>
</ul>
<h4 id="将非try-with的对象封装成可try-with的对象"><a href="#将非try-with的对象封装成可try-with的对象" class="headerlink" title="将非try-with的对象封装成可try-with的对象"></a>将非try-with的对象封装成可try-with的对象</h4><ul>
<li>实现AutoCloseable接口</li>
</ul>
<h3 id="线程异常捕获-——-UncaughtExceptionHandler"><a href="#线程异常捕获-——-UncaughtExceptionHandler" class="headerlink" title="线程异常捕获 —— UncaughtExceptionHandler"></a>线程异常捕获 —— UncaughtExceptionHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler((Thread t, Throwable e) -&gt;&#123;</span><br><span class="line">		System.err.println(t.getName() + <span class="string">" "</span> + e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="写单例需要考虑的"><a href="#写单例需要考虑的" class="headerlink" title="写单例需要考虑的"></a>写单例需要考虑的</h3><ul>
<li>初始化的线程安全.</li>
<li>反射干涉内部成员的初始化.</li>
<li>序列化带来的问题.</li>
<li>效率.</li>
</ul>
<h4 id="解决线程安全-amp-反射-amp-序列化"><a href="#解决线程安全-amp-反射-amp-序列化" class="headerlink" title="解决线程安全 &amp; 反射 &amp; 序列化"></a>解决线程安全 &amp; 反射 &amp; 序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignletonClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SignletonClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(DataHolder.LAZY != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error"</span>); <span class="comment">//解决反射</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SignletonClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> InstanceHolder.LAZY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解决线程安全: 内部类一定会在getInstance()调用之前初始化, 避免了线程安全问题.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SignletonClass LAZY = <span class="keyword">new</span> SignletonClass(); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123; <span class="comment">//重写readResolve()解决序列化</span></span><br><span class="line">    <span class="keyword">return</span> SignletonClass.getInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举式单例"><a href="#枚举式单例" class="headerlink" title="枚举式单例"></a>枚举式单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton&#123; <span class="comment">// 枚举类自带屏蔽反射, 序列化, 其初始化也是线程安全的, 效率也高.</span></span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">private</span> Object data;</span><br><span class="line">  <span class="comment">//getter &amp; setter..</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器单例模式"><a href="#容器单例模式" class="headerlink" title="容器单例模式"></a>容器单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(ioc)&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-vs-StringBuffer-vs-StringBuilder"><a href="#String-vs-StringBuffer-vs-StringBuilder" class="headerlink" title="String vs. StringBuffer vs. StringBuilder"></a>String vs. StringBuffer vs. StringBuilder</h3><ul>
<li>StringBuffer和StringBuilder在拼接字符串的时候均不会产生新的对象, 用法大体相同, 只是前者线程安全, 后者线程不安全.</li>
<li>StringBuilder的速度比StringBuffer高.</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/04/20/几点批判性思维的见解/" rel="next" title="对批判性思维的几点见解">
                  <i class="fa fa-chevron-left"></i> 对批判性思维的几点见解
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiang Tao</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Note"><span class="nav-number">1.</span> <span class="nav-text">Java Note</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-虚拟机内存布局"><span class="nav-number">1.1.</span> <span class="nav-text">I 虚拟机内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JVM运行时-内存布局"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. JVM运行时 内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-对象内存布局"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 对象内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-对象访问"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 对象访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-句柄访问"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">3.1 句柄访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-指针访问"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">3.2 指针访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#II-垃圾回收策略"><span class="nav-number">1.2.</span> <span class="nav-text">II 垃圾回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-回收理论"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 回收理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象存活判定"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">对象存活判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分代假说"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">分代假说</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收算法"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">回收算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-回收时机"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 回收时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-回收器例举"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 回收器例举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Serial-ParNew"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">3.1 Serial / ParNew</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-CMS-注重响应时间-停顿时间短"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">3.2 CMS(注重响应时间, 停顿时间短)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-G1-Mixed-GC"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3.3 G1 (Mixed GC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-ZGC"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">3.4 ZGC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#III-类加载机制"><span class="nav-number">1.3.</span> <span class="nav-text">III 类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-类加载步骤"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 类加载步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-类加载器"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载机制"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">类加载机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-反射系统"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 反射系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IV-多线程并发"><span class="nav-number">1.4.</span> <span class="nav-text">IV 多线程并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-内存模型"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性协议具体内容"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">一致性协议具体内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-关键字"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">volatile 关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线程实现"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程安全"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现线程安全编程"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">实现线程安全编程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-锁"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-可重入锁-java-util-concurrent-locks-ReentrantLock-vs-synchronized-关键字"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.1 可重入锁  java.util.concurrent.locks.ReentrantLock vs. synchronized 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-读写锁-Java-util-concurrent-locks-ReentrantReadWriteLock"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.2 读写锁 Java.util.concurrent.locks.ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-轻量锁"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.3 轻量锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-偏向锁"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">4.4 偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-自旋锁"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">4.5 自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-锁消除"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">4.6 锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-锁粗化"><span class="nav-number">1.4.4.7.</span> <span class="nav-text">4.7 锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-公平锁-非公平锁"><span class="nav-number">1.4.4.8.</span> <span class="nav-text">4.8 公平锁/非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-双锁检测-DCL-Double-Check-Lock"><span class="nav-number">1.4.4.9.</span> <span class="nav-text">4.9 双锁检测 DCL(Double Check Lock)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-Atomic类的实现原理"><span class="nav-number">1.4.4.10.</span> <span class="nav-text">4.10 Atomic类的实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-有序性-可见性-原子性"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. 有序性, 可见性, 原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-volatitle"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">5.1 volatitle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-synchronized"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">5.2 synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-final"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">5.3 final</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-long-amp-double"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. long&amp;double</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-线程池"><span class="nav-number">1.4.7.</span> <span class="nav-text">6. 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程同步"><span class="nav-number">1.4.8.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#notify-notifyAll-wait"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">notify()/notifyAll() + wait()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition-接口"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">Condition 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">1.4.8.4.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.4.8.5.</span> <span class="nav-text">CyclicBarrier</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#V-并发容器"><span class="nav-number">1.5.</span> <span class="nav-text">V 并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#J-U-C-CopyOnWrite系列容器-vs-Collections-synchronizedCollection"><span class="nav-number">1.5.1.</span> <span class="nav-text">J.U.C.CopyOnWrite系列容器 vs. Collections.synchronizedCollection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#J-U-C-ConcurrentHashMap-vs-Hashtable-vs-Collections-synchronizedMap"><span class="nav-number">1.5.2.</span> <span class="nav-text">J.U.C.ConcurrentHashMap vs. Hashtable vs.  Collections.synchronizedMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列-vs-并发队列-ArrayBlockingQueue-vs-ConcurrentLinkedQueue-vs-LinkedBlockingQueue"><span class="nav-number">1.5.3.</span> <span class="nav-text">阻塞队列 vs. 并发队列: ArrayBlockingQueue vs. ConcurrentLinkedQueue vs. LinkedBlockingQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VI-程序编译"><span class="nav-number">1.6.</span> <span class="nav-text">VI 程序编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-前端-Java语法糖"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 前端:  Java语法糖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型系统"><span class="nav-number">1.6.2.</span> <span class="nav-text">泛型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-泛型理论-协变-逆变-不变"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1. 泛型理论: 协变, 逆变, 不变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-泛型符号-和-T的区别"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">2. 泛型符号: ? 和 T的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-后端-JIT-编译优化"><span class="nav-number">1.6.3.</span> <span class="nav-text">2. 后端: JIT, 编译优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VII-Java-NIO"><span class="nav-number">1.7.</span> <span class="nav-text">VII Java NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-nio-ByteBuffer"><span class="nav-number">1.7.1.</span> <span class="nav-text">java.nio.ByteBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-nio-channels"><span class="nav-number">1.7.2.</span> <span class="nav-text">java.nio.channels.*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杂项"><span class="nav-number">1.8.</span> <span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-原理"><span class="nav-number">1.8.1.</span> <span class="nav-text">HashMap 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射的代价"><span class="nav-number">1.8.2.</span> <span class="nav-text">反射的代价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将非try-with的对象封装成可try-with的对象"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">将非try-with的对象封装成可try-with的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程异常捕获-——-UncaughtExceptionHandler"><span class="nav-number">1.8.3.</span> <span class="nav-text">线程异常捕获 —— UncaughtExceptionHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写单例需要考虑的"><span class="nav-number">1.8.4.</span> <span class="nav-text">写单例需要考虑的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决线程安全-amp-反射-amp-序列化"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">解决线程安全 &amp; 反射 &amp; 序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举式单例"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">枚举式单例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器单例模式"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">容器单例模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-vs-StringBuffer-vs-StringBuilder"><span class="nav-number">1.8.5.</span> <span class="nav-text">String vs. StringBuffer vs. StringBuilder</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Tao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
    var gitalk = new Gitalk({
      clientID: '718be8debab9c5679ffe',
      clientSecret: '0d04fe57f26db5e87925fb322d82ef56f7d41417',
      repo: 'git-talk',
      owner: 'VIXNESS',
      admin: ['VIXNESS'],
      id: 'f49820a188bbd06a1a64ece39c72fefe',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
